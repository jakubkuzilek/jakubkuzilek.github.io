---
title: "Student drop-out modelling using Virtual Learning Environment behaviour data"
author: ""
date: '2018-04-12'
output: pdf_document
summary: We analysed the data from OULAD dataset using Markov chains in order to model
  student drop-out based on their behaviour in Virtual Learning Environment.
tags:
- academic
- learning-analytics
- markov-chain-modelling
- VLE
categories: ["research"]
---

This post is a companion for the short paper submitted to [EC-TEL 2018 conference](http://www.ec-tel.eu/index.php?id=791). It 
contains details of the whole study and some more information such as figures, which 
does not fit in to the paper. For the analysis we used [Open University Learning Analytics dataset](https://github.com/jakubkuzilek/oulad).

> This is draft version of companion, if you spot an error, typo or you have any comment, please let me know.

# Setup
First we will load the required packages:
```{r}
library(tidyverse)
library(stringr)
library(oulad)
library(matlib)
library(DiagrammeR)
```

# Data
We will be using data from OULAD and we will stick with only one course presentation, 
namely *FFF*/*2014J*. At first, the student Virtual Learning Environment (VLE) activity logs 
and list of available VLE "resources"" is extracted:
```{r}
# available VLE resources
filtered_vle <- vle %>% 
  filter(code_module == "FFF", 
         code_presentation == "2014J")

str(filtered_vle)

# student activity logs
filtered_student_vle <- student_vle %>% 
  filter(code_module == "FFF", 
         code_presentation == "2014J")

str(filtered_student_vle)
```
It can be observed that there are 452 resources available to study for the course and 
more than 1.2 million records of student activity in VLE.

Since the first assessment will be considered in part of our research, the information 
is extracted from data.frame `assessment` and week, in which the assessment has cut-off date is computed:
```{r}
assessment_day <- assessment %>% 
  filter(code_module == "FFF", 
         code_presentation == "2014J", 
         assessment_type == "TMA") %>% 
  select(id_assessment, date) %>% 
  rename(assessment_day = date) %>% 
  mutate(assessment_week = ceiling(assessment_day/7))

assessment_day
```

We will also need the results of the first assessment:
```{r}
assessments <- assessment %>% 
  filter(code_module == "FFF", 
         code_presentation == "2014J",
         assessment_type == "TMA")

student_assessment_results <- student_assessment %>% 
  inner_join(assessments, by="id_assessment") %>% 
  select(id_student, id_assessment, date_submitted, is_banked, score) 

head(student_assessment_results)
```

Finally we will need student final outcome of the course to be able those who
withdrawn:
```{r}
student_final_results <- student %>% 
  filter(code_module == "FFF", 
         code_presentation == "2014J") %>% 
  select(id_student, final_result) 

student_unregistration <- student_registration %>% 
  filter(code_module == "FFF", 
         code_presentation == "2014J") %>% 
  select(id_student, date_unregistration)

student_final_results <- student_final_results %>% 
  left_join(student_unregistration, by = "id_student") %>% 
  mutate(date_unregistration = ceiling(date_unregistration/7))
```


Next the study plan information is refined:
```{r}
# study plan
plan <- filtered_vle %>% 
  mutate(week = week_from) %>% 
  select(id_site, 
         activity_type,
         week) %>% 
  arrange(week)

head(plan)

# count how many planned resources are scheduled for the week
planed_resources <- plan %>% 
  group_by(week) %>% 
  summarise(max_resources = n()) %>% 
  ungroup() %>% 
  filter(!is.na(week))

head(planed_resources)
```


The real student behaviour was prepared as follows. The activities from before the start of 
the course were excluded; for every log entry week, in which student did the activity,
is computed from the `date` and finally only columns of interest were extracted:
```{r}
reality <- filtered_student_vle %>% 
  filter(date >= 0L) %>% 
  mutate(date = if_else(date == 0L, 1L, date), 
         week = ceiling(date/7)) %>% 
  select(id_student,
         id_site,
         week)

head(reality)
```

Now we can combine real student behaviour with the plan:
```{r}
data_combined <- reality %>%
  rename(student_week = week) %>% 
  left_join(plan, by=c("id_site")) %>% 
  unique() %>% 
  rename(planned_week = week)

# example
data_combined %>% 
  filter(id_student == 35747) %>% 
  head()
```

If we look at plan, we can observe that there are planned activities up to week 29:
```{r}
plan %>% 
  select(week) %>% 
  max(na.rm = TRUE)
```

Thus we will focus only on first 29 weeks of studies.

We can now do activity categorization for the purpose of creating the Markov chain:
```{r}
# find out if student did something in the week according to the plan
student_activities <- data_combined %>% 
  select(-id_site) %>% 
  mutate(planned_week = if_else(is.na(planned_week),-1L,planned_week),
         planned = if_else(student_week == planned_week, "Y","N")) %>% 
  group_by(id_student, student_week, planned) %>%
  count() %>% 
  ungroup() %>% 
  rename(week = student_week)

# get maximum week in plan
maximal_planned_week <- planed_resources %>% 
  summarise(max(week)) %>% 
  as.integer()

# classify student activities:
# for planned activity we have 0 for none, E for some and A for all
# for nonplanned activity we have 0 for none and E for did something
# format PlannedNonplanned, example: A0 - all from the plan, nothing else
student_activities_classified <- student_activities %>% 
  filter(week <= maximal_planned_week) %>%
  left_join(planed_resources, by = "week") %>% 
  mutate(max_resources = if_else(planned == "N", n, max_resources),
         percentage = n/max_resources # proportion of planned activities in week
  ) %>% 
  select(-n, -max_resources) %>% 
  group_by(id_student, week) %>% 
  # spread proportion of planned and nonplanned activity proportion for each week 
  spread(planned, percentage, fill = 0) %>% 
  mutate(class = if_else(Y == 0, # if no planned activity
                         if_else(N == 0, # if no other activity
                                 "00",
                                 "0E"),
                          # if all planned activity else part of planned activity
                         if_else(Y == 1,
                                 if_else(N == 0, # if no other activity
                                         "A0",
                                         "AE"),
                                 if_else(N == 0, # if no other activity
                                         "E0",
                                         "EE")
                                 )
                         )
        ) %>% 
  select(-N, -Y)

head(student_activities_classified)
```

The problem we need to work on are students who do not engage with the VLE. We need
to include them and we can combine all the data with the final student outcome:
```{r}
unique_students <- student_final_results %>% 
  select(id_student) %>% 
  unique() %>% 
  unlist() %>% 
  unname()

weeks <- rep(1:maximal_planned_week, 
            length(unique_students)) 

students_with_all_weeks <- tibble(id_student = sort(rep(unique_students, 
                                                        maximal_planned_week)
                                                    ),
                                  week = weeks)

students_activities_classified_with_final_result <- students_with_all_weeks %>% 
  left_join(student_activities_classified, by=c("id_student","week")) %>% 
  mutate(class = if_else(is.na(class), "00", class)) %>% 
  left_join(student_final_results, by="id_student") %>% 
  mutate(class = if_else(week >= date_unregistration & !is.na(date_unregistration), 
                         "Withdrawn", 
                         class)
         ) %>% 
  select(-date_unregistration) %>% 
  mutate(final_result = if_else(final_result == "Distinction", "Pass", final_result))

head(students_activities_classified_with_final_result)
```

# Analysis

## Whole cohort
At first we will check how many samples we got for each activity cathegory (state):
```{r}
students_activities_classified_with_final_result %>% 
  group_by(class) %>% 
  count()
```

We can observe that `A0` is not presented in data and `E0` has only 7 representatives,
thus we will exclude them:
```{r}
students_to_remove <- students_activities_classified_with_final_result %>% 
  filter(class == "A0" | class == "E0") %>% 
  select(id_student) %>% 
  unique() %>% 
  .[[1]]

students_activities_classified_with_final_result <- students_activities_classified_with_final_result %>% 
  filter(!id_student %in% students_to_remove)
```

Since we will be constructing more than one chain, we define the function to do that:
```{r}
create_transition_matrix <- function(students_activities,
                                     states){

  # template
  transition_matrix <- matrix(data = numeric(), 
                              nrow = length(states),
                              ncol = length(states),
                              dimnames = list(states, states))
  
  # prepare data
  data_for_markov_chain <- students_activities %>% 
    select(-final_result) %>% 
    arrange(id_student, week) 
  
  
  state_vector <- data_for_markov_chain %>% 
    select(class) %>% 
    unlist() %>% 
    unname()
  
  state_vector <- c(state_vector[2:length(state_vector)],
                    state_vector[1])
  

  data_for_markov_chain$state_2 <- state_vector
  
  data_for_markov_chain <- data_for_markov_chain %>% 
    rename(state_1 = class) %>% 
    filter(week != max(week)) %>% 
    select(state_1, state_2)
  
  # count transitions
  for(state1 in states){
    for(state2 in states){
      n <- data_for_markov_chain %>%
        filter(state_1 == state1,
               state_2 == state2) %>%
        count() %>%
        as.numeric()
      
      transition_matrix[state1,state2] <- n
    }
  }
  
  # normalize be row sums
  normalization_matrix <- transition_matrix %>% 
    apply(1,sum) %>% 
    rep(length(states)) %>% 
    matrix(ncol = length(states), nrow = length(states))
  
  transition_matrix <- transition_matrix/normalization_matrix
  
  # return
  transition_matrix
}

```

Finally we can compute our first Markov chain transition matrix:
```{r}
# PLAN | OTHER ACTIVITIES OUTSIDE PLAN
# possible values: 
# PLAN: 0, E, A; OTHER: 0, E
states_P_1 <- c("00",
                "0E",
                # "E0", # filtered out
                "EE",
                #"A0", #f iltered out
                "AE",
                "Withdrawn")

transition_matrix_P_1 <- create_transition_matrix(students_activities_classified_with_final_result,
                                                  states_P_1)

# show transition matrix
(P_1 <- round(transition_matrix_P_1, 2)*100)
```

We can now visualize the Markov chain. We will exlude transition edges with probability less than 10 percent
to achive better readability of graph (with exception of `Withdrawn` column):
```{r}
P_1_tmp <- P_1
P_1_tmp[P_1 <= 10] <- 0
P_1_tmp[,5] <- P_1[,5]
graph <- from_adj_matrix(P_1_tmp, mode = "directed", weighted = T)
x <- graph$edges_df
x$label <- x$weight
graph$edges_df <- x

graph %>% render_graph()
```

We can now compute time to absorption in `Withdrawn` state, this is done using
computing of the fundamental matrix and again we will write the function to do that:
```{r}
fundamental_matrix <- function(transition_matrix,
                               states) {

n <- length(states)
Q <- transition_matrix[-n,-n]

I <- diag(n-1) 

fundamental_matrix <- inv(I-Q)

states[-n]

# fundamental matrix
list(fundamental_matrix = fundamental_matrix,
     # time to absorption
     absorption_time = fundamental_matrix %*% matrix(data=rep(1,n-1), nrow = n-1),
     # probability of absorption
     prob_of_absorption = fundamental_matrix %*% matrix(transition_matrix[-n,n],nrow=n-1)
)
}
```

And the result for the whole cohort is:
```{r}
fundamental_matrix(transition_matrix_P_1,
                   states_P_1)
```

## Students divided to those who submitted and who do not submitted first assessment

First we need to combine student activities with first assessment results:
```{r}
# select first assessment id
assessment_id <- assessments %>% 
  select(id_assessment) %>% 
  .[[1]] %>% 
  .[1]

# select results
assessment_results <- student_assessment_results %>% 
  filter(id_assessment == assessment_id) %>% 
  select(id_student, score)

# combine activities and results
students_activities_classified_with_assessment_result <- students_activities_classified_with_final_result %>%
  left_join(assessment_results, by = "id_student") %>% 
  mutate(submitted = if_else(is.na(score), "N", "Y")) %>% 
  select(-score) 

head(students_activities_classified_with_assessment_result)
```

Thanks to added information we can now split the students and perform the analysis on 
two groups - submitters and non-submitters, we will also filter out activities 
from first 4 weeks, since this is before the submission of the first assessment:
```{r}
submitted_students <- students_activities_classified_with_assessment_result %>%
  filter(submitted == "Y", week > 4) 

head(submitted_students)

non_submitted_students <- students_activities_classified_with_assessment_result %>%
  filter(submitted == "N", week > 4) 

head(non_submitted_students)
```

Again we can check how many samples we have for each activity:
```{r}
submitted_students %>% 
  group_by(class) %>% 
  count()

non_submitted_students %>% 
  group_by(class) %>% 
  count()
```
We can observe that some activities are not represented in the data, thus we will 
not be using them.

Now, we need to compute transtion matrices. At first for submitters:
```{r}
states_submitted <- c("00",
                      "0E",
                      "EE",
                      "AE",
                      "Withdrawn")

transition_matrix_P_2 <- create_transition_matrix(submitted_students, 
                                                  states_submitted)

# show transition matrix
(P_2 <- round(transition_matrix_P_2, 2)*100)

P_2_tmp <- P_2
P_2_tmp[P_2 <= 10] <- 0
P_2_tmp[,5] <- P_2[,5]
graph <- from_adj_matrix(P_2_tmp, mode = "directed", weighted = T)
x <- graph$edges_df
x$label <- x$weight
graph$edges_df <- x

graph %>% render_graph()
```

And now - non-submitters:
```{r}
states_non_submitted <- c("00",
                          "0E",
                          "EE",
                          "Withdrawn")

transition_matrix_P_3 <- create_transition_matrix(non_submitted_students, 
                                                 states_non_submitted)

# show transition matrix
(P_3 <- round(transition_matrix_P_3, 2)*100)

P_3_tmp <- P_3
P_3_tmp[P_3 <= 10] <- 0
P_3_tmp[,4] <- P_3[,4]
graph <- from_adj_matrix(P_3_tmp, mode = "directed", weighted = T)
x <- graph$edges_df
x$label <- x$weight
graph$edges_df <- x

graph %>% render_graph()
```

We can again compute fundamental matrix and time to absorption for both matrices:
```{r}
fundamental_matrix(transition_matrix_P_2,
                   states_submitted)

fundamental_matrix(transition_matrix_P_3,
                   states_non_submitted)
```


# Conclusions
We analysed one course from the OULAD data, namely FFF/2014J, using Markov chains.
From constructed graph representation we can observe several interesting facts:

1. students tends to do less next week
2. those who did nothing have larger probability to withdraw
3. if we analyse students who did not submitted first assessment those who did nothing
tends to do nothing and are passive for the whole course

For more details see the paper submitted for ECTEL conference. This is its online companion.